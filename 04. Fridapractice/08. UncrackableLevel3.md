


### 0.환경설정

https://mas.owasp.org/crackmes/ 에서 Uncrackable level3.apk 설치 후 진행


---

### 1. 솔루션 탐지 우회


#### Step 1. 로직 파악


- ![img.png](img.png)

루팅 탐지 중인 것을 확인함


- ![img_6.png](img_6.png)

checkRoot1 메서드는 환경변수에 등록된 파일 중 su가 존재하는지 확인하여 루팅 여부를 판단 

checkRoot2 메서드는 테스트키가 등록되어 있는지 확인하여 루팅 여부를 판단

checkRoot3 메서드는 루팅된 환경에서만 사용되는 알려진 패키지, 파일들이 존재하는지 확인하여 루팅 여부를 판단

우회를 위해 코드를 작성함

```js
Java.perform(function () {
    var java_lang_System = Java.use('sg.vantagepoint.util.RootDetection');
    java_lang_System.checkRoot1.implementation = function () {
        if (this.checkRoot1()) { console.log("[*] CheckRoot1 is bypassed"); } return false;
    }
    java_lang_System.checkRoot2.implementation = function () {
        if (this.checkRoot2()) { console.log("[*] CheckRoot2 is bypassed"); } return false;
    }
    java_lang_System.checkRoot3.implementation = function () {
        if (this.checkRoot3()) { console.log("[*] CheckRoot3 is bypassed"); } return false;
    }
});
```

후킹하여 실행 시 

- ![img_8.png](img_8.png)

단말기에서 확인 시 앱이 정상적인 종료가 아니라 완전히 종료됨

또한

- ![img_9.png](img_9.png)

프리다에서 로그 확인 시 보면

`signal 6 (SIGABRT), code -6 (SI_TKILL)` 

이 크래시는 앱이 일부러 자기 자신을 죽인 것이고, 정상 종료랑 완전히 다르다

👉 의도적으로 크래시 발생하는 방법으로 전형적인 anti-debug / anti-frida 트램폴린


/lib/arm64/libfoo.so 라이브러리 파일의 `0x000031ac` 에서 goodbye() 함수를 실행시킨 것으로 보인다.



---

#### Step 2. so 파일 분석

libfoo.so 파일을 분석하기 위해 

> apk 파일의 확장자를 zip 으로 바꾼 뒤 압축 해제하면 lib 폴더 내 라이브러리 추출이 가능하다


단말기의  OS bit를 확인한다.


`getprop ro.product.cpu.abi`

- ![img_50.png](Uncrackablelevel2_9.png)

lib 폴더 내 단말기 OS에 맞는 폴더로 이동한 뒤 libfoo.so 파일을 Ghidra 나 IDA 으로 분석 진행하면 된다


- ![img_10.png](img_10.png)

Ghdira의 코드 브라우저의 최상단에 가면 `0x00100000` 부터 시작하는 것을 알 수 있는데 기준 주소이다

내가 찾고자하는 주소 `0x000031ac`는 상대주소이니 기준 주소 + 상대주소 = `0x00100000` + `0x000031ac` = `0x001031ac` 이다


- ![img_11.png](img_11.png)

대문자 G 단축키 > `0x001031ac` 으로 이동하면

- ![img_12.png](img_12.png)

goodbye() 함수를 호출하는 부분으로 이동이 가능함

우측 디컴파일 창의 코드를 분석하면 대강 아래와 같다.

```text
※ 아래의 소스코드에 대한 라인 별 설명

17 라인 : 변수 __stream에 /proc/self/maps 파일을 읽기 권한으로 읽어드린다.
18 라인 : 파일을 읽어드리는데 실패하면 "Error opening /proc/self/maps! Terminating..." 문구를 pcVar1에 저장한다.
24 라인 : __stream에서 최대 0x200(512)바이트까지의 문자열을 읽어서 acStack_238 버퍼에 저장한다.
25 라인 : fget() 함수로 문자열을 성공적으로 읽은 경우 반복문을 중단한다.
36 라인 : acStack_238 문자열에서 "frida" 패턴을 찾은 경우 반복문을 종료한다.
39 라인 : acStack_238 문자열에서 "xposed" 패턴을 찾은 경우 더이상 반복하지 않는다.
40 라인 : "Tampering detected! Terminating..." 문구를 pcVar1에 저장한다.
43 라인 : pcVar1에 저장된 문구를 "UnCrackable3" 태그로 "INFO" 레벨의 로그로 출력한다.
45 라인 : 프로그램을 종료시키기위해 _exit(0) 코드를 사용하는 goodbye() 함수를 호출한다.
```


즉, frida, xposed 탐지 로직이며

방안은 2가지 정도로 생각할 수 있다.

1. strstr 함수에 후킹을 걸어 frida, xposed 문자열을 찾았을 때 반환 값을 0으로 변조하여 탐지 기능을 우회, strstr 함수는 표준 라이브러리 중 하나인 libc.so 내에 존재함
2. fopen 함수에 후킹을 걸어 /proc/self/maps 파일 대신 /proc/self/stat 파일을 분석하도록 하여 탐지 기능을 우회


1번의 방법으로 우회 코드를 작성한다

기존의 RootDetection 클래스의 checkRoot1,2,3 후킹 코드를 추가한 한 최종 우회 코드는 아래와 같다.

```js
Java.perform(function () {
    var java_lang_System = Java.use('sg.vantagepoint.util.RootDetection');
    // checkRoot1 메서드를 우회
    java_lang_System.checkRoot1.implementation = function () {
        if (this.checkRoot1()) {
            console.log("[*] CheckRoot1 is bypassed");  // checkRoot1이 호출된 경우 우회 로그 출력
        }
        return false;  // 루팅이 감지되었다고 가정하고 false를 반환하여 루팅 검사를 우회
    }
    // checkRoot2 메서드를 우회
    java_lang_System.checkRoot2.implementation = function () {
        if (this.checkRoot2()) {
            console.log("[*] CheckRoot2 is bypassed");  // checkRoot2가 호출된 경우 우회 로그 출력
        }
        return false;  // 루팅이 감지되었다고 가정하고 false를 반환하여 루팅 검사를 우회
    }
    // checkRoot3 메서드를 우회
    java_lang_System.checkRoot3.implementation = function () {
        if (this.checkRoot3()) {
            console.log("[*] CheckRoot3 is bypassed");  // checkRoot3가 호출된 경우 우회 로그 출력
        }
        return false;  // 루팅이 감지되었다고 가정하고 false를 반환하여 루팅 검사를 우회
    }
    
    var x = false;
    
    // 예제 1: 'libc.so'의 'strstr' 함수 훅킹
    Interceptor.attach(Module.getExportByName('libc.so', 'strstr'), {
        onEnter: function (args) {
            // 'strstr' 함수에서 첫 번째 인자(haystack)를 읽어들임 (검색할 큰 문자열)
            var haystack = Memory.readUtf8String(args[0]);
            
            // haystack 문자열에 'frida' 또는 'xposed'가 포함되어 있는지 검사
            if(haystack.indexOf('frida') !== -1 || haystack.indexOf('xposed') !== -1){
                x = true;  // 'frida'나 'xposed'를 찾으면 플래그를 설정
            }
        },
        onLeave: function (retval) {
            // 만약 'frida'나 'xposed'를 찾은 경우, 반환값을 수정하여 해당 문자열을 찾지 못하게 만듬
            if(x){
                retval.replace(0);  // strstr이 찾을 수 없게 하여 후속 코드가 정상적으로 실행되지 않도록 함
            }
        }
    });
});
```

- ![img_14.png](img_14.png)

루팅 및 Frida, Xposed 탐지 우회 성공!


---

참고로 위에서 로그를 통해 어디서 frida 를 탐지하는지 확인하였다.

이 방법 말고도 Frida 코드를 통해 어디서 Frida 탐지를 하는지 알 수 있는 방법이 있다.

```js
Java.perform(function() {
    // "strstr" 함수가 호출될 때 후킹을 시작
    Interceptor.attach(Module.findExportByName(null, "strstr"), {
        onEnter: function(args) {
            // 첫 번째 인자로 전달된 파일 이름을 읽어옵니다 (strstr 함수의 두 번째 인자).
            this.file_name = args[1].readCString();
            
            if (/frida/i.test(this.file_name)){
                console.warn("str: ", this.file_name); // 경고 메시지 출력 (frida 관련 파일이 발견된 경우)

                // 현재 스레드의 백트레이스를 출력하여 함수 호출 경로를 추적합니다.
                console.log(Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join('\n\t'));
            }
        }
    });
});

```


- ![img_16.png](img_16.png)



libfoo.so 파일의 0x3144 == 0x00003144(상대 주소) 에서 frida 문구를 비교하는 것을 알 수 있다

Ghidra에서의 0x00100000는 (기준주소)


`0x00100000는 (기준주소)` + `0x00003144(상대 주소)` = `0x00103144` 을 찾으면 된다

- ![img_17.png](img_17.png)

대문자 G 단축키 > `0x00103144` 으로 이동하면

- ![img_18.png](img_18.png)

해당 위치에서 frida 문자 비교하는 곳으로 이동하여 로직을 분석 가능하다.

---









